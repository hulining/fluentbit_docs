# 积压

在某些环境中，通常会遇到输入日志或数据比将其刷新到某些目标的速度快的场景。常见的情况是从大日志文件中读取日志并将日志通过网络分发到后端，这需要花费一些时间来做出响应，这会产生积压，从而导致服务中的内存消耗很高。

为了避免积压，Fluent Bit 在引擎中实现了一种限制输入插件可摄取的数据量的机制，这是通过配置参数 **Mem\_Buf\_Limit** 来实现的。

{% hint style="info" %}
如[缓冲](../concepts/buffering.md)概念部分中所述，Fluent Bit 提供了用于数据处理的混合模式: `memory` 和 `filesystem`\(可选的\)。

`memory` 是始终可用的，并且可以通过 **Mem\_Buf\_Limit** 参数进行限制。如果您的插件由于配置而受到限制，并且系统处于积压的情况下，则在刷新内存中的数据块之前，您将无法提取更多数据。

根据所使用的插件类型不同，可能会导致传入数据丢失\(例如：TCP 输入插件\)，您可以依靠辅助 `filesystem` 缓冲来确保数据安全。

如果除了 `Mem_Buf_Limi`t 之外，输入插件还定义了 `filesystem` 的 `storage.type`（如[缓冲与存储](buffering-and-storage.md)中所述\)，则在达到限制时，所有新数据将安全地存储在文件系统中。
{% endhint %}

## Mem\_Buf\_Limit

默认情况下，此选项是禁用的，并且可以应用于所有输入插件。让我们使用以下场景来说明其行为:

* Mem\_Buf\_Limit 设置为 1MB
* 输入插件尝试追加 700KB 的数据
* 引擎将数据路由到输出插件
* 输出插件后端\(HTTP 服务\)关闭
* 引擎调度程序将在 10 秒后重试将数据刷入输出插件
* 输入插件尝试追加 500KB 的数据

此时，引擎将**允许**将这 500KB 数据追加到引擎中: 总共有 1.2MB。这些选项在达到限制之前以宽容模式工作，但是**超出限制**会执行以下操作:

* 阻塞输入插件的本地缓冲区\(不能再追加数据\)
* 通知输入插件调用 **paused** 回调

引擎将自我保护，并且不会追加来自相关输入插件的更多数据；请注意，插件将保持其状态并针对 _paused_ 状态做出一些处理。

几秒钟后，如果调度程序能够将最初的 700KB 数据刷入后端输出或在重试后丢弃了这些数据，则数据的内存将被释放，并且内部将发生以下操作:

* 释放数据缓冲区\(700KB\)后，内部计数器将更新
* 计数器现在设置为 500KB
* 由于 500KB 未超过 Mem\_Buf\_Limit 设置的 1MB，它将检查输入插件状态
* 如果插件处于 paused 状态 ，它将调用 **resume** 回调
* 输入插件可以继续追加更多数据

## 关于 pause 和 resume 回调 <a id="about-pause-and-resume-callbacks"></a>

每个插件都是独立的，并非所有插件都实现 **pause** 和 **resume** 回调。如前所述，这些回调只是插件的通知机制

实现并保持良好状态的一个插件是 [Tail 输入插件](../pipeline/inputs/tail.md)。触发 **pause** 回调时，它将停止其收集器并停止追加数据。直到 **resume** 触发后，它将重新启用收集器。

